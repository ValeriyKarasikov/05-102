# Реализация линейной алгебры в ООП на ЯП С++

В рамках данного проекта необходимо выполнить реализацию **трёх** подзадач:

1. Определение архитектуры программы (директория `architecture`).
2. Реализация статических библиотек для обработки исключений и взаимодействия с
   внешними потоками данных, а также реализация "движка" -- линейной алгебры для
   скаляров, векторов и матриц (директория `libraries`).
3. Создание аппарата переменных на основе командного интерфейса программы
   (директория `variables`).

## Архитектура

Необходимо реализовать **три** *управляемых* класса (`Preprocessor`,
`Processor`, `Postprocessor`) и **один** *управляющий* класс (`Interpreter`).
Данные структуры данных определяют архитектуру проекта и предоставляют
возможность взаимодействия пользователя с функциями программы.

### Интерпретатор

Класс представляет собой интерпретатор команд, определённых псевдокодом
программы. Данные команды считываются из *log*-файла или принимаются из окна
терминала. Обработанные (интерпретированные) команды передаются в параметры
методов соответствующих *управляемых* классов. Пример написания *log*-файла:

```
set, x, 42i ! создаём переменную типа int: команда передаётся Preprocessor
out, x      ! выводим значение переменной в окно терминала: Postprocessor
pow, x, 3   ! возводим переменную <x> в степень <3>: Processor
out, x      ! снова выводим значение переменной в окно терминала: Postprocessor
```

Таким образом, записанная в *log*-файле команда считывается и интерпретируется
для дальнейшей возможности вызова необходимой функции исполнения.

### Препроцессор

Содержит методы предварительной обработки полученных из входных потоков
значений. В данный класс задач может входить вызов функций для создания
соответствующих переменных, переопределение пользовательских директорий и
прочее. Пример команд препроцессора:

```
set, x, 4.2f ! создание переменной типа float
dir, "/path" ! название директории для работы с файлами внутри программы
clr          ! полностью очистить рабочее пространство программы
```

### Процессор

Содержит методы для обработки полученных значений. В данном случае происходит
вызов соответствующих функций для выполнения операций линейной алгебры на основе
полученных из входного потока значений. Пример команд процессора:

```
pow, x, 3    ! возвести значение перерменной <x> в степень <3>
inc, x       ! инкрементировать значение переменной <x> на единицу
sum, y, x, z ! записать в переменную <y> результат суммы значений <x> и <z>
```

### Постпроцессор

Содержит методы постобработки вычисленных значений. В данном случае
предполагается форматный вывод результатов расчёта в текстовый файл, а также
определение некоторых показателей состояния программы, например, количество
созданных переменных, их имена, количество выделенной на данном этапе
оперативной памяти и прочее. Пример команд постпроцессора:

```
out, x, "file.txt"  ! записать значение переменной <x> в текстовый файл
out, var, num       ! вывести в окно терминала количество переменных
out, var, nms       ! вывести в окно терминала имена созданных переменных
out, log, "log.txt" ! записать в файл описание текущего состояния программы
```

## Библиотеки

Реализация библиотек, определяющих основные возможности программы. В данной
подзадаче необходимо корректно сформулировать задачи, которые позволяет решить
командный интерфейс пользователя.

### Алгебра

Содержит набор основных функций в виде аналогов операций над соответствующими
скалярными, векторными или матричными величинами. Пример объявления функций для
*скалярных* параметров:

```cpp
template<typename T>
void inc(T& t) noexcept;

template<typename T, std::size_t N>
void pow(T& t, const N& n);

template<typename T1, typename T2>
void sum(const T1& t1, const T2& t2) noexcept(true);

template<typename T1, typename T2>
void del(const T1& t1, const T2& t2) noexcept(false);
```

### Исключения

Содержит набор типов для обработки соответствующих исключений. Характер
исключений определяется задачами, которые решает программный комплекс. Пример
названия структур данных:

```cpp
struct invalid_data;     ! указаны неверные входные данные команды
struct unknown_data;     ! указано неизвестное значение параметра команды
struct unspecified_data; ! не указано значение параметра команды
struct undefined_data;   ! не задано значение параметра команды
```

### Файл

Содержит набор функций для работы с текстовыми файлами (чтение/запись). Пример
объявления функций:

```cpp
void read(std::string& line, std::string_view path);
void write(const std::string& line, std::string_view path);
template<typename Op> // Op -- operation (predicate)
void stream(std::filesystem::path path, std::ios_base::openmode om, Op op);
```

### Синтаксис

Содержит набор функций для работы со строками (выделение подстроки в строке,
удаление определённых символов и прочее). Пример объявления функций:

```cpp
std::list<std::string> split(std::string_view line, char separator);
bool isBounded(std::string_view line, char bound);
std::string toUppercase(std::string_view line);
```

### Терминал

Содержит набор функций для работы с окном терминала (чтение/вывод). Пример
объявления функций:

```cpp
// prefix -- некоторое сообщение перед вводом, например, текст "enter here >> "
void input(std::string& line, std:string_view prefix);
template<char end = '\n', char sep = ' ', typename... T>
void display(const T&... t);
```

## Переменные

### База данных

Представляет собой класс, определяющий возможность хранения значений заранее
заданного типа в динамической памяти. Каждый тип имеет свой идентификатор.
Пример объявления методов:

```cpp
bool exists(std::string_view name);
void set(std::string_view name, std::string_view value);
template<typename T>
void assign(T& t, std::string_view name);
```

### Библиотека

Содержит основные псевдонимы для работы с базой данных и соответствующие функции
интерпретации входных параметров для корректного вызова методов класса. Пример
определения псевдонимов и функций:

```cpp
// aliases:
using floating_point_type = double;
using integer_number_type = std::intmax_t;
using library_type = Database<floating_point_type, integer_number_type>;
// functions:
void interpret(floating_point_type& value, std::string_view line);
void interpret(integer_number_type& value, std::string_view line);
```
